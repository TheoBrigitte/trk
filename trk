#!/bin/bash

set -eu

TRK_BIN="trk"
GIT_BIN="git"
OPENSSL_BIN="openssl"

SHARE_DIR=~/.local/share/trk
GIT_REPO_DIR="$SHARE_DIR/repo.git"
GIT_REPO_TRK_DIR="$GIT_REPO_DIR/trk"
PASSPHRASE_FILE="$GIT_REPO_TRK_DIR/passphrase"

OPENSSL_DEFAULT_ARGS="-aes-256-cbc -md sha256 -pbkdf2"

help_command() {
  cat <<EOF
Usage: $TRK_BIN <command> [options]

Git wrapper for managing repositories with specific worktrees.
Any git command can be used as a <command>.

Commands:
  init                Initialize a new repository with a specific worktree
  clone               Clone a repository with a specific worktree
  mark                Mark a file to be encrypted when committed
  unmark              Remove encryption mark from a file
  export-key          Get the encryption key
  openssl set-args    Set OpenSSL arguments for encryption and decryption
  openssl get-args    Get OpenSSL arguments for encryption and decryption
  openssl reset-args  Reset OpenSSL arguments to default
  help                Show this help message

Options:

  -f, --force  Force the command

Files:
  Repository: $GIT_REPO_DIR
  Worktree: $($GIT_BIN config core.worktree)
EOF
}

# Git commands

clone_help_command() {
  cat <<EOF
Usage: $TRK_BIN clone <repository> [options]

Clone a repository into the current worktree.

Options:

  -f, --force  Force the command
EOF
}

# Clone a repository with a specific worktree
# Worktree is left unchanged if there are local changes
clone_command() {
  if [ $# -lt 2 ]; then
    clone_help_command
    exit 0
  fi

  if [ -d "$GIT_REPO_DIR" ]; then
    if [ "$FORCE" = true ]; then
      rm -rf "$GIT_REPO_DIR"
    else
      echo "Repository already exists. Use -f to force."
      exit 1
    fi
  fi

  worktree="$(realpath -e "$1")"
  shift

  echo "Cloning repository with worktree $worktree"

  # Clone the repository
  $GIT_BIN clone --no-checkout --bare "$@" "$GIT_DIR"
  configure_repo "$worktree"

  # Get changes from the cloned repository into the index
  $GIT_BIN reset --mixed --quiet

  # Check if there are local changes
  modified_files="$($GIT_BIN ls-files --modified)"
  if [ -n "$modified_files" ]; then
    cat <<EOF
Local files differ from the cloned repository.
Review and apply the changes manually.

  $TRK_BIN status
  $TRK_BIN checkout -- <file> # keep remote changes
  $TRK_BIN add <file>         # keep local changes
EOF
    exit 1
  fi
}

init_help_command() {
  cat <<EOF
Usage: $TRK_BIN init <worktree> [options]

Initialize a new repository for the given worktree.

Options:

  -f, --force  Force the command
EOF
}

# Initialize a new repository with a specific worktree
# Encryption passphrase is generated and stored in a file
init_command() {
	if [ $# -lt 1 ]; then
    init_help_command
    exit 0
  fi

  if [ -d "$GIT_REPO_DIR" ]; then
    if [ "$FORCE" = true ]; then
      rm -rf "$GIT_REPO_DIR"
    else
      echo "Repository already exists. Use -f to force."
      exit 1
    fi
  fi

  worktree="$(realpath -e "$1")"
  echo "Initializing repository for worktree $worktree"

  # Initialize the repository
  $GIT_BIN init --bare
  configure_repo "$worktree"

  mkdir -p "$GIT_REPO_TRK_DIR"

  # Generate encryption passphrase
  < /dev/urandom tr -cd "[:print:]" | head -c 32 > "$PASSPHRASE_FILE"
}

# Encryption

# Generate a git attribute for a file
# This attribute is used to mark files that should be encrypted
generate_attribute() {
  echo "$1 filter=crypt diff=crypt merge=crypt"
}

mark_help_command() {
  cat <<EOF
Usage: $TRK_BIN mark <file>

Mark a file to be encrypted when committed.

Options:

  -f, --force  Force the command
EOF
}

# Mark a file to be encrypted when committed
mark_command() {
  if [ $# -lt 1 ]; then
    mark_help_command
    exit 0
  fi

  git_root="$($GIT_BIN rev-parse --show-toplevel)"
  # Create .gitattributes file if it doesn't exist
  [ -f "$git_root/.gitattributes" ] || touch "$git_root/.gitattributes"

  # Add the git attribute for the file
  src="$(realpath --relative-to "$git_root" -e "$1")"
  attribute=$(generate_attribute "$src")
  if grep -qE "^${attribute}$" "$git_root/.gitattributes" >/dev/null; then
    echo "$1 is already marked for encryption."
  else
    echo "$attribute" >> "$git_root/.gitattributes"
  fi
  $GIT_BIN add "$git_root/.gitattributes"
}

unmark_help_command() {
  cat <<EOF
Usage: $TRK_BIN unmark <file>

Remove encryption mark from a file.

Options:

  -f, --force  Force the command
EOF
}

# Remove encryption mark from a file
unmark_command() {
  if [ $# -lt 1 ]; then
    unmark_help_command
    exit 0
  fi

  git_root="$($GIT_BIN rev-parse --show-toplevel)"
  # Create .gitattributes file if it doesn't exist
  [ -f "$git_root/.gitattributes" ] || touch "$git_root/.gitattributes"

  # Remove the git attribute for the file
  src="$(realpath --relative-to "$git_root" -e "$1")"
  attribute=$(generate_attribute "$src")
  set -x
  sed -i "\#^${attribute}\$#d" "$git_root/.gitattributes"
  $GIT_BIN add "$git_root/.gitattributes"
}

# Display the encryption key
export-key_command() {
  cat "$PASSPHRASE_FILE"
}

# Get OpenSSL arguments used for encryption and decryption
openssl-get-args_command() {
  $GIT_BIN config trk.openssl-args
}

# Reset OpenSSL arguments to default
openssl-reset-args_command() {
  $GIT_BIN config --local trk.openssl-args "$OPENSSL_DEFAULT_ARGS"
}

# Set OpenSSL arguments used for encryption and decryption
openssl-set-args_command() {
  # It is required to escape the arguments here first
  args="$@"
  $GIT_BIN config --local trk.openssl-args "$args"
}

# Internal commands for git filters

# Generate a salt for encryption
# In order for clean/smudge filters to work correctly, the process must be idempotent.
# Therefore the salt is unique per file and is generated using the passphrase and the filename.
generate_salt() {
  cat "$PASSPHRASE_FILE" | openssl dgst -hmac "$1" -sha256 | tr -d '\r\n' | tail -c16
}

# Encrypt a file use OpenSSL
git-encrypt_command() {
  salt=$(generate_salt "${1}")
  openssl enc -e $OPENSSL_DEFAULT_ARGS -pass "file:$PASSPHRASE_FILE" -S "$salt"
}

# Decrypt a file use OpenSSL
git-decrypt_command() {
  salt=$(generate_salt "${1}")
  inputfile="$(mktemp -t trk-encrypt.XXXXXXXXXX)"
  outputfile="$(mktemp -t trk-encrypt.XXXXXXXXXX)"
  trap 'rm -f "$inputfile"' EXIT
  if tee "$inputfile"|openssl enc -d $OPENSSL_DEFAULT_ARGS -pass "file:$PASSPHRASE_FILE" -S "$salt" -out "$outputfile" 2>/dev/null; then
    cat "$outputfile"
  else
    # There are cases where this function receive an unencrypted file
    # For instance when a merge conflict occurs, the merge conflict file is passed to this function
    cat "$inputfile"
  fi
}

# Merge a file using git merge-file
# It does so by decrypting the files, performing the merge, and encrypting the result back
git-merge_command() {
  base=$1     # Base file
  current=$2  # Current branch version
  other=$3    # Other branch version
  marker=$4   # Conflict marker size
  dest=$5     # Destination file

  base_temp="$(mktemp -t trk-merge.XXXXXXXXXX)"
  current_temp="$(mktemp -t trk-merge.XXXXXXXXXX)"
  other_temp="$(mktemp -t trk-merge.XXXXXXXXXX)"
  trap 'rm -f "$base_temp" "$current_temp" "$other_temp"' EXIT

  # Decrypt files
  cat "$base"    | git-decrypt_command "$dest" > "$base_temp"
  cat "$current" | git-decrypt_command "$dest" > "$current_temp"
  cat "$other"   | git-decrypt_command "$dest" > "$other_temp"

  cp "$base_temp"    "$base"
  cp "$current_temp" "$current"
  cp "$other_temp"   "$other"

  other_branch=$(echo "$GIT_REFLOG_ACTION" | awk '{print $2}')

  # Perform the merge on decrypted content
  git merge-file --marker-size="$marker" -L HEAD -L BASE -L "$other_branch" "$current" "$base" "$other"

  # Encrypt merged result back
  cat "$current" | git-encrypt_command "$dest" > "$current_temp"
  cp "$current_temp" "$current"
}

# Hooks

add_command_post() {
  if [ $1 -eq 128 ]; then
    echo "only files in the $($GIT_BIN config core.worktree) worktree are allowed."
  fi
}

# Helpers

# Configure the git repository with worktree, encryption filters, and other settings
configure_repo() {
  worktree="$1"
  $GIT_BIN config --local core.bare false
  $GIT_BIN config --local core.worktree "$worktree"
  $GIT_BIN config --local status.showUntrackedFiles no
  $GIT_BIN config --local trk.managed true

  $GIT_BIN config --local filter.crypt.required true
  $GIT_BIN config --local filter.crypt.clean  "$TRK_BIN git encrypt %f"
  $GIT_BIN config --local filter.crypt.smudge "$TRK_BIN git decrypt %f"
  $GIT_BIN config --local merge.crypt.driver  "$TRK_BIN git merge %O %A %B %L %P"
  $GIT_BIN config --local diff.crypt.textconv cat
  openssl-reset-args_command
}

# Ensure that the required directories are available
ensure_dir() {
  [ -d "$SHARE_DIR" ] || mkdir -p "$SHARE_DIR"
  if [ -d "$GIT_REPO_DIR" ]; then
    [ -d "$GIT_REPO_TRK_DIR" ] || mkdir -p "$GIT_REPO_TRK_DIR"
    [ -f "$PASSPHRASE_FILE" ] || { echo >&2 "Passphrase file not found. Aborting."; exit 1; }
  fi
}

# Ensure that the required binaries are available
ensure_bins() {
  command -v $GIT_BIN >/dev/null 2>&1 || { echo >&2 "Git is required but not installed. Aborting."; exit 1; }
  command -v $OPENSSL_BIN >/dev/null 2>&1 || { echo >&2 "OpenSSL is required but not installed. Aborting."; exit 1; }
}

# Set the environment variables for the git repository
# The GIT_DIR environment variable is used by git to determine the repository location
set_env() {
  export GIT_DIR="$GIT_REPO_DIR"
}

main() {
  set_env
  ensure_dir
  ensure_bins

  # Handle no arguments case
  if [ $# -lt 1 ]; then
    help_command
    exit 0
  fi

  # Handle commands and subcommands
  COMMAND="$1"
  shift

  case "$COMMAND" in
    openssl|git)
      SUBCOMMAND="$1"
      shift
      COMMAND="$COMMAND-$SUBCOMMAND"
      ;;
  esac

  # Handle options
  FORCE=false

  args=()
  while [[ $# -gt 0 ]] ; do
    case "$1" in
      -f|--force)
        FORCE=true
        shift 1
        continue
        ;;
      *)
        args+=("$1")
        shift 1
        ;;
    esac
  done


  # Execute the command
  if declare -F "${COMMAND}_command" &>/dev/null; then
    "${COMMAND}_command" "${args[@]}"
  else
    $GIT_BIN "$COMMAND" "${args[@]}"
  fi

  #if declare -F "${COMMAND}_command_post" &>/dev/null; then
  #  "${COMMAND}_command_post" "$git_exit_code" "${args[@]}"
  #fi
}

main "$@"
