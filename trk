#!/bin/bash

set -eu

TRK_BIN="trk"
GIT_BIN="git"
OPENSSL_BIN="openssl"

SHARE_DIR=~/.local/share/trk
GIT_REPO_DIR="$SHARE_DIR/repo.git"
GIT_REPO_TRK_DIR="$GIT_REPO_DIR/trk"
PASSPHRASE_FILE="$GIT_REPO_TRK_DIR/passphrase"

OPENSSL_DEFAULT_ARGS="-aes-256-cbc -md sha256 -pbkdf2"

help_command() {
  cat <<EOF
Usage: $TRK_BIN <command> [options]

Git wrapper for managing repositories with specific worktrees.
Any git command can be used as a <command>.

Commands:
  init                Initialize a new repository with a specific worktree
  clone               Clone a repository with a specific worktree
  mark                Mark a file to be encrypted when committed
  unmark              Remove encryption mark from a file
  export-key          Get the encryption key
  openssl set-args    Set OpenSSL arguments for encryption and decryption
  openssl get-args    Get OpenSSL arguments for encryption and decryption
  openssl reset-args  Reset OpenSSL arguments to default
  help                Show this help message

Options:

  -f, --force  Force the command

Files:
  Repository: $GIT_REPO_DIR
  Worktree: $($GIT_BIN config core.worktree)
EOF
}

# Git commands

clone_help_command() {
  cat <<EOF
Usage: $TRK_BIN clone <repository> [options]

Clone a repository into the current worktree.

Options:

  -f, --force  Force the command
EOF
}

clone_command() {
  if [ $# -lt 2 ]; then
    clone_help_command
    exit 0
  fi

  if [ -d "$GIT_REPO_DIR" ]; then
    if [ "$FORCE" = true ]; then
      rm -rf "$GIT_REPO_DIR"
    else
      echo "Repository already exists. Use -f to force."
      exit 1
    fi
  fi

  worktree="$(realpath -e "$1")"
  shift

  echo "Cloning repository with worktree $worktree"

  $GIT_BIN clone --no-checkout --bare "$@" "$GIT_DIR"
  configure_repo "$worktree"
  $GIT_BIN reset --mixed --quiet
  modified_files="$($GIT_BIN ls-files --modified)"
  if [ -n "$modified_files" ]; then
    cat <<EOF
Local files differ from the cloned repository.
Review and apply the changes manually.

  $TRK_BIN status
  $TRK_BIN checkout -- <file> # keep remote changes
  $TRK_BIN add <file> # keep local changes
EOF
    exit 1
  fi
}

init_help_command() {
  cat <<EOF
Usage: $TRK_BIN init <worktree> [options]

Initialize a new repository for the given worktree.

Options:

  -f, --force  Force the command
EOF
}

init_command() {
	if [ $# -lt 1 ]; then
    init_help_command
    exit 0
  fi

  if [ -d "$GIT_REPO_DIR" ]; then
    if [ "$FORCE" = true ]; then
      rm -rf "$GIT_REPO_DIR"
    else
      echo "Repository already exists. Use -f to force."
      exit 1
    fi
  fi

  worktree="$(realpath -e "$1")"
  echo "Initializing repository for worktree $worktree"

  $GIT_BIN init --bare
  configure_repo "$worktree"

  mkdir -p "$GIT_REPO_TRK_DIR"
  < /dev/urandom tr -cd "[:print:]" | head -c 32 > "$PASSPHRASE_FILE"
}

# Encryption

generate_attribute() {
  src="$1"
  echo "$src filter=crypt diff=crypt"
}

mark_help_command() {
  cat <<EOF
Usage: $TRK_BIN mark <file>

Mark a file to be encrypted when committed.

Options:

  -f, --force  Force the command
EOF
}

mark_command() {
  if [ $# -lt 1 ]; then
    mark_help_command
    exit 0
  fi

  git_root="$($GIT_BIN rev-parse --show-toplevel)"
  src="$(realpath --relative-to "$git_root" -e "$1")"
  attribute=$(generate_attribute "$src")
  [ -f "$git_root/.gitattributes" ] || touch "$git_root/.gitattributes"
  if grep -qE "^${attribute}$" "$git_root/.gitattributes" >/dev/null; then
    echo "$1 is already marked for encryption."
  else
    echo "$attribute" >> "$git_root/.gitattributes"
  fi
  $GIT_BIN add "$git_root/.gitattributes"
}

unmark_help_command() {
  cat <<EOF
Usage: $TRK_BIN unmark <file>

Remove encryption mark from a file.

Options:

  -f, --force  Force the command
EOF
}

unmark_command() {
  if [ $# -lt 1 ]; then
    unmark_help_command
    exit 0
  fi

  git_root="$($GIT_BIN rev-parse --show-toplevel)"
  src="$(realpath --relative-to "$git_root" -e "$1")"
  attribute=$(generate_attribute "$src")
  [ -f "$git_root/.gitattributes" ] || touch "$git_root/.gitattributes"
  set -x
  sed -i "\#^${attribute}\$#d" "$git_root/.gitattributes"
  $GIT_BIN add "$git_root/.gitattributes"
}

export-key_command() {
  cat "$PASSPHRASE_FILE"
}

generate_salt() {
  cat "$PASSPHRASE_FILE" | openssl dgst -hmac "$1" -sha256 | tr -d '\r\n' | tail -c16
}

clean_command() {
  salt=$(generate_salt "${1}")
  openssl enc -e $OPENSSL_DEFAULT_ARGS -pass "file:$PASSPHRASE_FILE" -S "$salt"
}

smudge_command() {
  salt=$(generate_salt "${1}")
  openssl enc -d $OPENSSL_DEFAULT_ARGS -pass "file:$PASSPHRASE_FILE" -S "$salt"
}

openssl-get-args_command() {
  $GIT_BIN config trk.openssl-args
}

openssl-reset-args_command() {
  $GIT_BIN config --local trk.openssl-args "$OPENSSL_DEFAULT_ARGS"
}

openssl-set-args_command() {
  args="$@"
  $GIT_BIN config --local trk.openssl-args "$args"
}

# Hooks

add_command_post() {
  if [ $1 -eq 128 ]; then
    echo "only files in the $($GIT_BIN config core.worktree) worktree are allowed."
  fi
}

# Helpers

configure_repo() {
  worktree="$1"
  $GIT_BIN config --local core.bare false
  $GIT_BIN config --local core.worktree "$worktree"
  $GIT_BIN config --local status.showUntrackedFiles no
  $GIT_BIN config --local trk.managed true

  $GIT_BIN config --local filter.crypt.required true
  $GIT_BIN config --local filter.crypt.clean "$TRK_BIN clean %f"
  $GIT_BIN config --local filter.crypt.smudge "$TRK_BIN smudge %f"
  $GIT_BIN config --local diff.crypt.textconv cat
  openssl-reset-args_command
}

ensure_dir() {
  [ -d "$SHARE_DIR" ] || mkdir -p "$SHARE_DIR"
}

ensure_bins() {
  command -v $GIT_BIN >/dev/null 2>&1 || { echo >&2 "Git is required but not installed. Aborting."; exit 1; }
  command -v $OPENSSL_BIN >/dev/null 2>&1 || { echo >&2 "OpenSSL is required but not installed. Aborting."; exit 1; }
}

set_env() {
  export GIT_DIR="$GIT_REPO_DIR"
}

main() {
  set_env
  ensure_dir
  ensure_bins

  # handle no arguments case
  if [ $# -lt 1 ]; then
    help_command
    exit 0
  fi

  COMMAND="$1"
  shift

  case "$COMMAND" in
    openssl|git)
      SUBCOMMAND="$1"
      shift
      COMMAND="$COMMAND-$SUBCOMMAND"
      ;;
  esac

  FORCE=false

  args=()
  while [[ $# -gt 0 ]] ; do
    case "$1" in
      -f|--force)
        FORCE=true
        shift 1
        continue
        ;;
      *)
        args+=("$1")
        shift 1
        ;;
    esac
  done


  if declare -F "${COMMAND}_command" &>/dev/null; then
    "${COMMAND}_command" "${args[@]}"
  else
    $GIT_BIN "$COMMAND" "${args[@]}"
  fi

  #if declare -F "${COMMAND}_command_post" &>/dev/null; then
  #  "${COMMAND}_command_post" "$git_exit_code" "${args[@]}"
  #fi
}

main "$@"
