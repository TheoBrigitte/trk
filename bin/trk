#!/usr/bin/env bash
#
# Author: Th√©o Brigitte
# Date: 2025-10-12

# Usage: trk <command> [options]
#
# Git wrapper for managing a repository and encrypting files.
#
# Any git command can be used as a <command>.
#
# Commands:
#   init                 Initialize a new repository
#   clone                Clone a repository
#   setup                Setup the repository to use trk
#   unsetup              Unsetup the repository from trk
#   worktree             Show the git repository worktree and git dir
#   version              Show version information
#   help                 Show this help message
#
#   > Encryption <
#   mark                 Mark a file or pattern to be encrypted when committed
#   unmark               Remove encryption mark
#   crypt                Git crypt subcommands
#
#   > Configuration <
#   permissions apply    Apply stored permissions to files
#   permissions refresh  Refresh the stored permissions with current file permissions
#   permissions status   Check the status of file permissions
#
# Global options:
#   -h, --help            Show help for any command


set -aeuo pipefail
shopt -s extglob

# Paths
SHARED_GIT_DIR=~/.local/share/trk/repo.git
PREFIX_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd -P)"
HOOKS_DIR="$PREFIX_DIR/lib/trk/hooks"

# Options
ENCRYPTION_ENABLED=true
PERMISSIONS_ENABLED=true
KEY_FILE=""
PRUNE=false
WORKTREE=""
set +a

# Binaries dependencies
GIT_BIN=git
GIT_CRYPT_BIN=git-crypt
# This binary
TRK_BIN="$(basename "$0")"
TRK_VERSION="dev"

# Usage: trk help [ <command> ]
#
# Print help message for a specific command
help_command() {
  # Extract usage from the script comments
  # Comments must start with "# Usage: arguments.sh" followed by the command name(s).
  # Comments can have at most 1 space identation.
  # If no command is given, print the general usage

  # This command works as follows:
  # 1. /#\s?Usage: /   -> Search for the line starting with "# Usage: arguments.sh <command>
  # 2. /^([^#]|$)/{p;  -> Print all subsequent lines starting with "#" until a line not starting with "#" is found
  # 3. /^([^#]|$)/q}   -> Force quit after the first non-comment line to avoid printing other usage sections
  # 4. '$d; s/#\s\?//' -> Remove the last line (non-comment) and strip leading "# " from each line
  sed -Ene '/#\s?Usage: '"$TRK_BIN $*"'/,/^([^#]|$)/{p; /^([^#]|$)/q}' "$0" | sed -e '$d; s/#\s\?//' | envsubst
  exit
}

# Print to stderr
echo_stderr() {
  echo -e "$@" 1>&2
}

error() {
  echo_stderr "ERROR: $1"
  exit 1
}

# Join strings with a delimiter
join_by() {
  local IFS="$1"; shift
  echo "$*"
}

##########################################
#         Git override commands          #
##########################################

# Usage: trk clone [ --worktree <path> ] <git options>...
#
# Clone a repository
# Worktree is left unchanged if there are local changes
#
#
# Options:
#   --key-file <path>     Path to the encryption key
#   --worktree <path>     Set the worktree path
#                         When using this option, the repository is globally available and cloned in $SHARED_GIT_DIR
clone_command() {
  if [[ -z "$KEY_FILE" ]]; then
    # This is to avoid generating an new encryption key
    # when cloning the repository in order to prevent misconfiguration.
    # Encryption can be setup explicitly after cloning.
    ENCRYPTION_ENABLED=false
  fi

  if [[ -n "$WORKTREE" ]]; then
    clone_global "$@"
  else
    clone_normal "$@"
  fi
}

# Clone a repository and configure it to be managed by trk
clone_normal() {
  # Unset GIT_DIR to make git clone to work with the current directory
  unset GIT_DIR

  # Capture the output of git clone to extract the directory name
  # TODO: could be replaced by using a tempoary directory and moving it afterward
  # since git clone should only create a single directory
  exec 3>&1
  output="$("$GIT_BIN" clone --no-checkout "$@" 2>&1 | tee /dev/fd/3)"
  exec 3>&-
  directory="$(echo "$output" | sed -nE "s/Cloning into '(.+)'\.\.\./\1/p")"

  cd "$directory"
  export GIT_DIR="$("$GIT_BIN" rev-parse --git-dir)"

  configure_repo

  "$GIT_BIN" checkout --quiet

  configure_repo_encryption
}

# Clone a repository as a global repository with a specific worktree
# worktree is left unchanged if there are local changes
clone_global() {
  if [[ $# -ne 1 ]]; then
    error "Missing remote repository"
  fi

  worktree="$(realpath -e "$WORKTREE")"
  remote_repo="$1"

  # Clone the repository
  mkdir -p "$SHARED_GIT_DIR"
  "$GIT_BIN" clone --config core.sharedrepository=umask --no-checkout --bare "$remote_repo" "$SHARED_GIT_DIR"

  configure_repo
  configure_repo_global "$worktree"

  # Get changes from the cloned repository into the index
  "$GIT_BIN" reset --quiet --mixed HEAD

  # Checkout files from the index to the worktree (if they don't exist yet)
  "$GIT_BIN" ls-files --deleted | "$GIT_BIN" checkout --quiet --pathspec-from-file -

  if ! output="$("$GIT_BIN" diff --name-status --exit-code HEAD)"; then
    cat <<-EOF

		Local files differ from the cloned repository. Review and apply the changes manually.
		Changes:
		$output

		$TRK_BIN checkout -- <file> # keep remote changes
		$TRK_BIN add <file>         # keep local changes
		EOF

    if "$ENCRYPTION_ENABLED" && [[ -n "$KEY_FILE" ]]; then
      echo "$TRK_BIN crypt unlock $KEY_FILE # to decrypt files after resolving conflicts"
    fi

    exit 1
  fi

  configure_repo_encryption
}

# Usage: trk init [ --worktree <path> ] <git options>...
#
# Initialize a new repository as global repository with a specific worktree
#
# Options:
#   --worktree <path>        Set the worktree path
#                            When using this option, the repository is globally available and created in $SHARED_GIT_DIR
#   --with[out]-encryption   Setup encryption for the repository (default on)
#   --with[out]-permissions  Setup permission tracking for the repository (default on)
init_command() {
  if [[ -n "$WORKTREE" ]]; then
    init_global "$@"
  else
    init_normal "$@"
  fi
}

init_normal() {
  # Unset GIT_DIR to make git init to work with the current directory
  unset GIT_DIR

  "$GIT_BIN" init "$@"

  # Change to the repository directory if not current directory
  [[ "$#" -gt 0 ]] && cd "${@: -1}"

  export GIT_DIR="$("$GIT_BIN" rev-parse --git-dir)"

  configure_repo
  configure_repo_encryption
}

# Initialize a new repository as global repository with a specific worktree
init_global() {
  worktree="$(realpath -e "$WORKTREE")"

  echo "Initializing repository with worktree $worktree"

  # Initialize the repository
  # Using the standard git init procedure and remove the temporary directory afterward to only keep git dir
  # This is to avoid any --bare shenanigans
  # The git dir is set by GIT_DIR environment variable
  temp_dir="$(mktemp -d -t trk-init.XXXXXXXXXX)"
  trap 'rm -rf "$temp_dir"' EXIT
  "$GIT_BIN" init --shared=umask "$temp_dir/repo" "$@"

  if "$ENCRYPTION_ENABLED"; then
    "$GIT_CRYPT_BIN" init
  fi

  configure_repo
  configure_repo_global "$worktree"
  configure_repo_encryption
}

##########################################
#     Git-crypt override commands        #
##########################################

# Usage: trk crypt status
#
# List encrypted files
crypt_status_command() {
  "$GIT_BIN" ls-tree -r HEAD --name-only | xargs "$GIT_CRYPT_BIN" status -e
}

##########################################
#             Trk commands               #
##########################################

# Usage: trk setup
#
# Setup the repository to use trk
#
# Options:
#   --with[out]-encryption   Setup encryption for the repository (default on)
#   --with[out]-permissions  Setup permission tracking for the repository (default off)
setup_command() {
  configure_repo
  configure_repo_encryption
}

# Usage: trk unsetup
#
# Unsetup the repository from trk
# Encryption cannot be disabled
#
# Options:
#   --prune    Remove all trk related configuration and files from the repository
unsetup_command() {
  if "$PRUNE"; then
    "$GIT_BIN" config remove-section --local "trk" 2>/dev/null || true
    git_root="$("$GIT_BIN" rev-parse --show-toplevel)"
    rm -f "$git_root/.gitattributes" "$git_root/.gitpermissions"
  else
    "$GIT_BIN" config set --local trk.managed false
  fi

  #encryption_disable
  permissions_disable

  echo "WARNING: encryption cannot be disabled"
}

# Usage: trk worktree
#
# Show the git repository worktree and git dir
worktree_command() {
  repository="$("$GIT_BIN" rev-parse --absolute-git-dir)"
  worktree="$("$GIT_BIN" rev-parse --path-format=absolute --show-toplevel)"

  echo "worktree: $worktree"
  echo "gitdir:   $repository"
}

# Usage: trk permissions apply
#
# Apply the permissions stored in .gitpermissions
permissions_apply_command() {
  "$GIT_BIN" hook run post-checkout
}

# Usage: trk permissions refresh
#
# Refresh the .gitpermissions file with current file permissions
permissions_refresh_command() {
  "$GIT_BIN" hook run pre-commit
}

# Usage: trk permissions status
#
# Check the status of file permissions against .gitpermissions
permissions_status_command() {
  git_root="$("$GIT_BIN" rev-parse --show-toplevel)"
  [[ -f "$git_root/.gitpermissions" ]] || error ".gitpermissions file not found"

  cat "$git_root/.gitpermissions" | while read -r line; do
    # Split line into file path and permissions
    file="$(echo "$line" | awk -F: '{print $1}')"
    perm="$(echo "$line" | awk -F: '{print $2}')"
    if [[ ! -e "$git_root/$file" ]]; then
      echo "[ERR] $file: does not exist, skipping..."
      continue
    fi

    actual_perm="$(stat -c "%a" "$git_root/$file" 2>&1)"
    if [[ "$actual_perm" == "$perm" ]]; then
      echo "[OK]  $file: $perm"
    else
      echo "[ERR] $file: mismatch (expected $perm, actual $actual_perm)"
    fi
  done
}

# Usage: trk mark <file or pattern>
#
# Add a pattern to match files for encryption when committed
#
# Patterns need to be quoted to prevent shell expansion.
# Patterns are gitattributes patterns, similar to .gitignore.
#
# Options:
#   -f, --force  Force the command
mark_command() {
  if [[ $# -lt 1 ]]; then
    echo "Missing file or pattern."
    exit 1
  fi

  git_root="$("$GIT_BIN" rev-parse --show-toplevel)"
  # Create .gitattributes file if it doesn't exist
  [[ -f "$git_root/.gitattributes" ]] || touch "$git_root/.gitattributes"

  # Add the git attribute for the file
  src="$(realpath --relative-to "$git_root" "$1")"
  attribute=$(generate_attribute "$src")
  escaped_attribute="${attribute//\*/\\*}"
  match="$(sed -n "\#^${escaped_attribute}\$#p" "$git_root/.gitattributes")"
  if [[ -n "$match" ]]; then
    echo "$1 is already marked for encryption."
  else
    echo "$attribute" >> "$git_root/.gitattributes"
  fi
  "$GIT_BIN" add "$git_root/.gitattributes"
}

# Usage: trk unmark <file or pattern>
#
# Remove encryption mark
#
# Options:
#   -f, --force  Force the command
unmark_command() {
  if [[ $# -lt 1 ]]; then
    echo "Missing file or pattern."
    exit 1
  fi

  git_root="$("$GIT_BIN" rev-parse --show-toplevel)"
  # Create .gitattributes file if it doesn't exist
  [[ -f "$git_root/.gitattributes" ]] || touch "$git_root/.gitattributes"

  # Remove the git attribute for the file
  src="$(realpath --relative-to "$git_root" "$1")"
  attribute=$(generate_attribute "$src")
  escaped_attribute="${attribute//\*/\\*}"
  sed -i "\#^${escaped_attribute}\$#d" "$git_root/.gitattributes"
  "$GIT_BIN" add "$git_root/.gitattributes"
}

# Usage: trk version
#
# Show version for trk and its dependencies
version_command() {
  echo "trk version $TRK_VERSION"
  "$GIT_BIN" version
  "$GIT_CRYPT_BIN" version
}

##########################################
#              Functions                 #
##########################################

# Enable permission tracking
permissions_enable() {
  cp -i "$HOOKS_DIR/"* "$GIT_DIR/hooks/"
  "$GIT_BIN" config set --local trk.permissions true
}

# Disable permission tracking
permissions_disable() {
  rm -f "$GIT_DIR/hooks/pre-commit" "$GIT_DIR/hooks/post-checkout"
  "$GIT_BIN" config set --local trk.permissions false
}

# This attribute is used to mark files that should be encrypted
generate_attribute() {
  # Escape spaces in the path
  # gitattributes uses [[:space:]] to represent spaces
  # https://github.com/git/git/blob/8d8387116ae8c3e73f6184471f0c46edbd2c7601/Documentation/gitattributes.txt#L563-L564
  escaped_path="${1//\ /[[:space:]]}"
  echo "$escaped_path filter=crypt diff=crypt merge=crypt"
}

##########################################
#            Configuration               #
##########################################

# Configure the git repository with
# - trk settings:
#   - permissions
#     - hooks
configure_repo() {
  # Always set trk.managed to true
  "$GIT_BIN" config set --local trk.managed true 2>/dev/null
  "$GIT_BIN" config unset --local core.bare 2>/dev/null

  # Setup permissions tracking if enabled
  # Doing this after importing configuration in order to detect if permissions tracking is enabled in the imported configuration
  permissions_enabled="$("$GIT_BIN" config get --local --default "false" trk.permissions)"
  if "$PERMISSIONS_ENABLED" || [[ "$permissions_enabled" == "true" ]]; then
    permissions_enable
  else
    permissions_disable
  fi
}

# Configure the git repository encryption with git-crypt
# - decrypt if a key file is provided
# - initialize git-crypt if encryption is enabled but not set
configure_repo_encryption() {
  if ! "$ENCRYPTION_ENABLED"; then
    return
  fi

  # Check if encryption is currently set in the repository
  encryption_set="$("$GIT_BIN" config get --local --default "false" filter.crypt.required)"

  if [[ -n "$KEY_FILE" ]]; then
    # If a key file was provided, decrypt the repository
    "$GIT_CRYPT_BIN" unlock "$KEY_FILE"
    return
  fi

  if [[ "$encryption_set" != "true" ]]; then
    # If encryption was requested but not set, initialize git-crypt
    "$GIT_CRYPT_BIN" init
  fi
}

# Configure the git repository with
# - worktree
# - hide untracked files
configure_repo_global() {
  worktree="$1"
  "$GIT_BIN" config set --local core.worktree "$worktree"
  "$GIT_BIN" config set --local status.showUntrackedFiles no
}

# Ensure that the required binaries are available
check_dependency() {
  command -v "$1" >/dev/null 2>&1 || error "$1 is not installed"
}

main() {
  # Print help if no arguments are given
  # Also catch help flag early
  if [[ -z "$*" || "$1" =~ -h ]]; then
    help_command
  fi

  # Validate dependencies are installed
  check_dependency "$GIT_BIN"
  check_dependency "$GIT_CRYPT_BIN"

  # Detect if we are in a git repository
  if ! "$GIT_BIN" rev-parse --absolute-git-dir &>/dev/null; then
    export GIT_DIR="$SHARED_GIT_DIR"
  fi

  # Fallback to git for non internal commands
  internal_commands="$(declare -pF|awk -F _ 'match($0, /([^ ]+)_command$/, m) {print m[1]}'|paste -sd'|'|tr '_' ' ')"
  matcher="^($internal_commands)"
  if [[ ! "$*" =~ $matcher ]]; then
    # Fallback to git-crypt for crypt commands
    if [[ "$1" == "crypt" ]]; then
      shift
      exec "$GIT_CRYPT_BIN" "$@"
    fi

    exec "$GIT_BIN" "$@"
  fi

  # Process arguments
  args=()
  show_help=false
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help)
        show_help=true;;
      --key-file)
        KEY_FILE="$2"
        [[ -z "$KEY_FILE" ]] && error "--key-file requires an argument"
        [[ ! -f "$KEY_FILE" ]] && error "$KEY_FILE file not found"
        shift;;
      --prune)
        PRUNE=true;;
      --with?(out)-@(encryption|permissions))
        option="${1##*-}"
        option="${option^^}_ENABLED"
        # Extra safety: check if the variable exists
        if [[ ! "${!option+set}" ]]; then
          echo "Invalid option: $1"
          exit 1
        fi
        if [[ $1 =~ --without-* ]]; then
          declare "$option"=false
        else
          declare "$option"=true
        fi;;
      --worktree)
        WORKTREE="${2-}"
        [[ -z "$WORKTREE" ]] && error "--worktree requires an argument"
        shift;;
      -?*)
        error "Unknown option: $1";;
      *)
        args+=("$1");;
    esac
    shift
  done

  # Restore positional arguments
  set -- "${args[@]}"

  # Build trk command
  # This loop is necessary to allow for optional subcommands
  cmd=""
  for ((i=0; i<$#; i++)); do
    # Try every positional arguments combination in reverse order
    cmd_parts=("${@:1:$#-$i}")
    # cmd_parts is not quoted on purpose to split into array elements
    # shellcheck disable=SC2068
    cmd_probe="$(join_by _ ${cmd_parts[@]})_command"
    if declare -F "$cmd_probe" &>/dev/null; then
      cmd="$cmd_probe"
      shift $(($#-i))
      break
    fi
  done

  if [[ -z "$cmd" ]]; then
    error "Unknown command: ${cmd_parts[*]}"
  fi

  if "$show_help"; then
    # Display help message and exit.
    help_command "${cmd_parts[*]}"
  fi

  # Validate that the repository is initialized
  # Only validate now to allow for help to be shown
  if [[ ! -d "$SHARED_GIT_DIR" ]] && [[ "$cmd" != init_command && "$cmd" != clone_command ]]; then
    error "$TRK_BIN was not initialized. Run init or clone to initialize."
  fi

  # Run trk
  "$cmd" "$@"
}

main "$@"
