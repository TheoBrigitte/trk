#!/usr/bin/env bash
#
# Author: Th√©o Brigitte
# Date: 2025-10-12

# Usage: trk <command> [ <options> ] [ <git options> ]
#
# Git wrapper for managing a repository and encrypting files.
#
# Any git command can be used as a <command>.
#
# Commands:
#   init                 Initialize a new repository
#   clone                Clone a repository
#   setup                Setup the repository to use trk
#   unsetup              Unsetup the repository from trk
#   worktree             Show the git repository worktree and git dir
#   version              Show version information
#   help                 Show this help message
#
#   > Encryption <
#   mark                 Mark a file or pattern to be encrypted when committed
#   unmark               Remove encryption mark
#   crypt                Git crypt subcommands
#
#   > Configuration <
#   permissions apply    Apply stored permissions to files
#   permissions refresh  Refresh the stored permissions with current file permissions
#   permissions status   Check the status of file permissions
#
# Global options:
#   -h, --help            Show help for any command


set -aeuo pipefail
shopt -s extglob

# Paths
SHARED_GIT_DIR=~/.local/share/trk/repo.git
PREFIX_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd -P)"
HOOKS_DIR="$PREFIX_DIR/lib/trk/hooks"
PERMISSIONS_LIST_FILE=".trk/permissions_list"
PERMISSIONS_FILE=".trk/permissions"

# Options
ENCRYPTION_ENABLED=true
PERMISSIONS_ENABLED=true
KEY_FILE=""
WORKTREE=""
set +a

# Binaries dependencies
GIT_BIN=git
GIT_CRYPT_BIN=git-crypt
# This binary
TRK_BIN="$(basename "$0")"
TRK_VERSION="dev"

# Usage: trk help [ <command> ]
#
# Print help message for a specific command
help_command() {
  # Extract usage from the script comments
  # Comments must start with "# Usage: arguments.sh" followed by the command name(s).
  # Comments can have at most 1 space identation.
  # If no command is given, print the general usage

  # This command works as follows:
  # 1. /#\s?Usage: /   -> Search for the line starting with "# Usage: arguments.sh <command>
  # 2. /^([^#]|$)/{p;  -> Print all subsequent lines starting with "#" until a line not starting with "#" is found
  # 3. /^([^#]|$)/q}   -> Force quit after the first non-comment line to avoid printing other usage sections
  # 4. '$d; s/#\s\?//' -> Remove the last line (non-comment) and strip leading "# " from each line
  sed -Ene '/#\s?Usage: '"$TRK_BIN $*"'/,/^([^#]|$)/{p; /^([^#]|$)/q}' "$0" | sed -e '$d; s/#\s\?//' | envsubst
  exit
}

# Print to stderr
echo_stderr() {
  echo -e "$@" 1>&2
}

error() {
  echo_stderr "ERROR: $1"
  exit 1
}

# Join strings with a delimiter
join_by() {
  local IFS="$1"; shift
  echo "$*"
}

##########################################
#         Git override commands          #
##########################################

# Usage: trk clone [ <options> ] [ <git options> ]
#
# Clone a repository
# Worktree is left unchanged if there are local changes
#
#
# Options:
#   --key-file <path>     Path to the encryption key
#   --worktree <path>     Set the worktree path
#                         When using this option, the repository is globally available and cloned in $SHARED_GIT_DIR
clone_command() {
  if [[ -z "$KEY_FILE" ]]; then
    # This is to avoid generating an new encryption key
    # when cloning the repository in order to prevent misconfiguration.
    # Encryption can be setup explicitly after cloning.
    ENCRYPTION_ENABLED=false
  fi

  if [[ -n "$WORKTREE" ]]; then
    clone_global "$@"
  else
    clone_normal "$@"
  fi

  configure_repo_encryption
}

# Clone a repository and configure it to be managed by trk
clone_normal() {
  git_capture_worktree clone --no-checkout "$@"

  configure_repo

  "$GIT_BIN" checkout --quiet
}

# Clone a repository as a global repository with a specific worktree
# worktree is left unchanged if there are local changes
clone_global() {
  if [[ $# -ne 1 ]]; then
    error "Missing remote repository"
  fi

  worktree="$(realpath -e "$WORKTREE")"
  remote_repo="$1"

  mkdir -p "$SHARED_GIT_DIR"

  # Clone the repository
  "$GIT_BIN" clone --config core.sharedrepository=umask --no-checkout --bare "$remote_repo" "$SHARED_GIT_DIR"

  configure_repo
  configure_repo_global "$worktree"

  # Get changes from the cloned repository into the index
  "$GIT_BIN" reset --quiet --mixed HEAD

  # Checkout files from the index to the worktree (if they don't exist yet)
  "$GIT_BIN" ls-files --deleted | "$GIT_BIN" checkout --quiet --pathspec-from-file -

  if ! output="$("$GIT_BIN" diff --name-status --exit-code HEAD)"; then
    cat <<-EOF

		Local files differ from the cloned repository. Review and apply the changes manually.
		Changes:
		$output

		$TRK_BIN checkout -- <file> # keep remote changes
		$TRK_BIN add <file>         # keep local changes
		EOF

    if "$ENCRYPTION_ENABLED" && [[ -n "$KEY_FILE" ]]; then
      echo "$TRK_BIN crypt unlock $KEY_FILE # to decrypt files after resolving conflicts"
    fi

    exit 1
  fi
}

# Usage: trk init [ <options> ] [ <git options> ]
#
# Initialize a new repository as global repository with a specific worktree
#
# Options:
#   --key-file <path>        Path to the encryption key
#   --worktree <path>        Set the worktree path
#                            When using this option, the repository is globally available and created in $SHARED_GIT_DIR
#   --with[out]-encryption   Setup encryption for the repository (default on)
#   --with[out]-permissions  Setup permission tracking for the repository (default on)
init_command() {
  if [[ -n "$WORKTREE" ]]; then
    init_global "$@"
  else
    init_normal "$@"
  fi

  configure_repo_encryption
}

init_normal() {
  git_capture_worktree init "$@"

  configure_repo
}

git_capture_worktree() {
  # Unset GIT_DIR to ensure git works with the current directory
  unset GIT_DIR

  # Capture the trace output of git to extract the worktree directory name
  # fd/4 is used to capture stdout and stderr of git while fd/3 is used for trace
  exec 4>&1

  # Run git
  # GIT_TRACE2=3 writes trace to fd/3
  output="$(GIT_TRACE2=3 "$GIT_BIN" "$@" 3>&1 &>/dev/fd/4)"

  exec 4>&-
  directory="$(echo "$output" | awk '$3 == "worktree" {print $4}')"
  if [[ ! -d "$directory" ]]; then
    error "Failed to determine git worktree after: $GIT_BIN $@"
  fi

  cd "$directory"
  export GIT_DIR="$("$GIT_BIN" rev-parse --git-dir)"
}

# Initialize a new repository as global repository with a specific worktree
init_global() {
  worktree="$(realpath -e "$WORKTREE")"

  echo "Initializing repository with worktree $worktree"

  # Initialize the repository
  # Using the standard git init procedure and remove the temporary directory afterward to only keep git dir
  # This is to avoid any --bare shenanigans
  # The git dir is set by GIT_DIR environment variable
  temp_dir="$(mktemp -d -t trk-init.XXXXXXXXXX)"
  trap 'rm -rf "$temp_dir"' EXIT
  mkdir -p "$(dirname "$SHARED_GIT_DIR")"

  # Initialize the repository
  "$GIT_BIN" init --shared=umask "$temp_dir/repo" "$@"

  configure_repo
  configure_repo_global "$worktree"
}

##########################################
#     Git-crypt override commands        #
##########################################

# Usage: trk crypt status
#
# List encrypted files
crypt_status_command() {
  "$GIT_BIN" ls-tree -r HEAD --name-only | xargs "$GIT_CRYPT_BIN" status -e
}

##########################################
#             Trk commands               #
##########################################

# Usage: trk setup [ <options> ]
#
# Setup the repository to use trk
#
# Options:
#   --with[out]-encryption   Setup encryption for the repository (default on)
#   --with[out]-permissions  Setup permission tracking for the repository (default off)
setup_command() {
  configure_repo
  configure_repo_encryption
}

# Usage: trk unsetup [ <options ]
#
# Unsetup the repository from trk
# Encryption cannot be disabled
unsetup_command() {
  "$GIT_BIN" config set --local trk.managed false

  # TODO: link this to git-crypt lock
  #encryption_disable
  permissions_disable

  echo "WARNING: encryption cannot be disabled"
}

# Usage: trk worktree
#
# Show the git repository worktree and git dir
worktree_command() {
  repository="$("$GIT_BIN" rev-parse --absolute-git-dir)"
  worktree="$("$GIT_BIN" rev-parse --path-format=absolute --show-toplevel)"

  echo "worktree: $worktree"
  echo "gitdir:   $repository"
}

# Usage: trk permissions mark <file>
permissions_mark_command() {
  if [[ $# -lt 1 ]]; then
    echo "Missing file."
    exit 1
  fi

  # resolve the path relative to the git root, and validate it exists
  src="$(realpath --canonicalize-existing --relative-to "$GIT_ROOT" "$1")"
  # ensure .trk directory is created
  mkdir -p "$GIT_ROOT/.trk"
  # Check if the file is already marked for permission tracking.
  # Match permissions markers against src, if got a match, it means that src is a child of MATCH
  if [[ -f "$GIT_ROOT/$PERMISSIONS_LIST_FILE" ]] && MATCH="$(echo "$src" | grep -qFf "$GIT_ROOT/$PERMISSIONS_LIST_FILE")"; then
    echo_stderr "$src is already marked for permission tracking by: $MATCH"
    return
  fi

  # Add the file to the permissions tracking list
  echo "$src" >> "$GIT_ROOT/$PERMISSIONS_LIST_FILE"
  "$GIT_BIN" add "$GIT_ROOT/$PERMISSIONS_LIST_FILE"
  # TODO: refresh permissions
}

# Usage: trk permissions unmark <file>
permissions_unmark_command() {
  if [[ $# -lt 1 ]]; then
    echo "Missing file."
    exit 1
  fi

  # Not validating the path exists to allow unmarking deleted files
  src="$(realpath --canonicalize-missing --relative-to "$GIT_ROOT" "$1")"
  if [[ ! -f "$GIT_ROOT/$PERMISSIONS_LIST_FILE" ]]; then
    echo_stderr "No permissions are being tracked."
    return
  fi

  if ! grep -qFx "$src" "$GIT_ROOT/$PERMISSIONS_LIST_FILE"; then
    if MATCH="$(echo "$src" | grep -qFf "$GIT_ROOT/$PERMISSIONS_LIST_FILE")"; then
      echo_stderr "$src permissions are being tracked by: $MATCH"
      return 1
    fi

    echo_stderr "$src is not marked for permission tracking"
    return
  fi

  # Remove the file from the permissions tracking list
  sed -i "\#^${src}\$#d" "$GIT_ROOT/$PERMISSIONS_LIST_FILE"
  "$GIT_BIN" add "$GIT_ROOT/$PERMISSIONS_LIST_FILE"
}

# Usage: trk permissions apply
#
# Apply the permissions stored in .gitpermissions
permissions_apply_command() {
  # Apply the permissions stored in .gitpermissions using setfacl
  if [[ ! -f "$GIT_ROOT/$PERMISSIONS_FILE" ]]; then
    echo_stderr "No $PERMISSIONS_FILE file found, skipping permission application."
    return
  fi

  echo_stderr "Applying stored file permissions from $PERMISSIONS_FILE."

  # Apply the permissions using setfacl
  (
    set -eu
    cd "$GIT_ROOT"
    setfacl ${SETFACL_FLAGS-} --restore="$GIT_ROOT/$PERMISSIONS_FILE"
  )
}

# Usage: trk permissions refresh
#
# Refresh the .gitpermissions file with current file permissions
permissions_refresh_command() {
  "$GIT_BIN" hook run pre-commit
}

hook_pre-commit_command() {
  # Generate a list of current file permissions in the repository
  # and save it to .gitpermissions file in the root of the repository.
  # Uses getfacl to capture base ACL entries only (owner, group, other).

  # Generate the .gitpermissions file using getfacl
  # Exclude .gitpermissions itself from tracking
  # Use -z and xargs -0 to handle filenames with spaces
  if [[ ! -f "$GIT_ROOT/$PERMISSIONS_LIST_FILE" ]]; then
    echo_stderr "No permissions files to track, skipping .gitpermissions update."
    exit
  fi

  if ! git diff-index --cached --name-only HEAD -z -- | grep -zqFf "$GIT_ROOT/$PERMISSIONS_LIST_FILE"; then
    echo_stderr "No tracked files changed, skipping .gitpermissions update." 1>&2
    exit
  fi

  echo_stderr "Updating $PERMISSIONS_FILE with current file permissions."
  (
    set -eu
    cd "$GIT_ROOT"
    xargs -a "$GIT_ROOT/$PERMISSIONS_LIST_FILE" getfacl -R --access > "$GIT_ROOT/$PERMISSIONS_FILE"
  )

  git add "$GIT_ROOT/$PERMISSIONS_FILE"
}

hook_post-checkout_command() {
  previous_head="$1"
  new_head="$2"

  # Restore file permissions from the .gitpermissions file after checkout
  # Uses setfacl to restore base ACL entries (owner, group, other).

  #[[ -f "$GIT_ROOT/.trk/permissions" ]] || exit 0

  # Always apply if null-ref was given (e.g. clone)
  if ! echo "$previous_head" | grep -qx '0\+'; then
    if ! git diff "$previous_head" "$new_head" --name-only -z | grep -zqF -e "$PERMISSIONS_FILE" -f "$GIT_ROOT/$PERMISSIONS_LIST_FILE"; then
      echo_stderr "Tracked files did not change, skipping permission application."
      return
    fi
  fi

  permissions_apply_command
}

# Usage: trk permissions status
#
# Check the status of file permissions against .gitpermissions
permissions_status_command() {
  SETFACL_FLAGS="--test"
  permissions_apply_command
}

# Usage: trk mark <file or pattern>
#
# Add a pattern to match files for encryption when committed
#
# Patterns need to be quoted to prevent shell expansion.
# Patterns are gitattributes patterns, similar to .gitignore.
#
# Options:
#   -f, --force  Force the command
mark_command() {
  if [[ $# -lt 1 ]]; then
    echo "Missing file or pattern."
    exit 1
  fi

  if [[ "$("$GIT_BIN" config get --local --default "false" filter.git-crypt.required)" != "true" ]]; then
    error "Encryption is not enabled in this repository. Run 'trk setup' to enable encryption."
  fi

  if [[ "$("$GIT_BIN" config get --local --default "false" filter.git-crypt.clean)" != '"git-crypt" clean' ]]; then
    error "Git-crypt filter is not properly configured. Run 'trk setup' to enable encryption."
  fi

  git_root="$("$GIT_BIN" rev-parse --show-toplevel)"
  # Create .gitattributes file if it doesn't exist
  [[ -f "$git_root/.gitattributes" ]] || touch "$git_root/.gitattributes"

  # Add the git attribute for the file
  src="$(realpath --canonicalize-missing --relative-to "$git_root" "$1")"
  attribute=$(generate_attribute "$src")
  escaped_attribute="${attribute//\*/\\*}"
  match="$(sed -n "\#^${escaped_attribute}\$#p" "$git_root/.gitattributes")"
  if [[ -n "$match" ]]; then
    echo "$1 is already marked for encryption."
  else
    echo "$attribute" >> "$git_root/.gitattributes"
  fi
  "$GIT_BIN" add "$git_root/.gitattributes"
}

# Usage: trk unmark <file or pattern>
#
# Remove encryption mark
#
# Options:
#   -f, --force  Force the command
unmark_command() {
  if [[ $# -lt 1 ]]; then
    echo "Missing file or pattern."
    exit 1
  fi

  git_root="$("$GIT_BIN" rev-parse --show-toplevel)"
  # Create .gitattributes file if it doesn't exist
  [[ -f "$git_root/.gitattributes" ]] || touch "$git_root/.gitattributes"

  # Remove the git attribute for the file
  src="$(realpath --relative-to "$git_root" "$1")"
  attribute=$(generate_attribute "$src")
  escaped_attribute="${attribute//\*/\\*}"
  sed -i "\#^${escaped_attribute}\$#d" "$git_root/.gitattributes"
  "$GIT_BIN" add "$git_root/.gitattributes"
}

# Usage: trk version
#
# Show version for trk and its dependencies
version_command() {
  echo "trk version $TRK_VERSION"
  "$GIT_BIN" version
  "$GIT_CRYPT_BIN" version
}

##########################################
#              Functions                 #
##########################################

# Enable permission tracking
permissions_enable() {
  git_hook_dir="$(git rev-parse --git-path hooks)"
  cp -i "$HOOKS_DIR/"* "$git_hook_dir/"
}

# Disable permission tracking
permissions_disable() {
  git_hook_dir="$(git rev-parse --git-path hooks)"
  rm -f "$git_hook_dir/pre-commit" "$git_hook_dir/post-checkout"
}

# This attribute is used to mark files that should be encrypted
generate_attribute() {
  # Escape spaces in the path
  # gitattributes uses [[:space:]] to represent spaces
  # https://github.com/git/git/blob/8d8387116ae8c3e73f6184471f0c46edbd2c7601/Documentation/gitattributes.txt#L563-L564
  escaped_path="${1//\ /[[:space:]]}"
  echo "$escaped_path filter=git-crypt diff=git-crypt"
}

##########################################
#            Configuration               #
##########################################

# Configure the git repository with
# - trk settings:
#   - permissions
#     - hooks
configure_repo() {
  # Always set trk.managed to true
  "$GIT_BIN" config set --local trk.managed true
  "$GIT_BIN" config unset --local core.bare || true

  configure_repo_permissions
}

configure_repo_permissions() {
  # User explicitly disabled permissions tracking
  if ! "$PERMISSIONS_ENABLED"; then
    return
  fi

  ## Setup permissions tracking if enabled
  ## Doing this after importing configuration in order to detect if permissions tracking is enabled in the imported configuration
  #permissions_enabled="$("$GIT_BIN" config get --local --default "false" trk.permissions)"
  #if [[ "$permissions_enabled" == "true" ]]; then
  permissions_enable
  #else
  #  permissions_disable
  #fi
}

# Configure the git repository encryption with git-crypt
# - decrypt if a key file is provided
# - initialize git-crypt if encryption is enabled but not set
configure_repo_encryption() {
  # User explicitly disabled encryption
  if ! "$ENCRYPTION_ENABLED"; then
    return
  fi

  # Check if encryption is currently set in the repository
  encryption_set="$("$GIT_BIN" config get --local --default "false" filter.git-crypt.required)"

  if [[ -n "$KEY_FILE" ]]; then
    # If a key file was provided, decrypt the repository
    "$GIT_CRYPT_BIN" unlock "$KEY_FILE"
    return
  fi

  if [[ "$encryption_set" != "true" ]]; then
    # If encryption was requested but not set, initialize git-crypt
    "$GIT_CRYPT_BIN" init
  fi
}

# Configure the git repository with
# - worktree
# - hide untracked files
configure_repo_global() {
  worktree="$1"
  "$GIT_BIN" config set --local core.worktree "$worktree"
  "$GIT_BIN" config set --local status.showUntrackedFiles no
}

# Ensure that the required binaries are available
check_dependency() {
  command -v "$1" >/dev/null 2>&1 || error "$1 is not installed"
}

main() {
  # Print help if no arguments are given
  # Also catch help flag early
  if [[ -z "$*" || "$1" =~ -h ]]; then
    help_command
  fi

  # Validate dependencies are installed
  check_dependency "$GIT_BIN"
  check_dependency "$GIT_CRYPT_BIN"

  # When not inside a git repository, operatore on the shared repository.
  if ! "$GIT_BIN" rev-parse --absolute-git-dir &>/dev/null; then
    export GIT_DIR="$SHARED_GIT_DIR"
  fi

  # Fallback to git for non internal commands
  internal_commands="$(declare -pF|awk -F _ 'match($0, /([^ ]+)_command$/, m) {print m[1]}'|paste -sd'|'|tr '_' ' ')"
  matcher="^($internal_commands)"
  if [[ ! "$*" =~ $matcher ]]; then
    # Fallback to git-crypt for crypt commands
    if [[ "$1" == "crypt" ]]; then
      shift
      exec "$GIT_CRYPT_BIN" "$@"
    fi

    exec "$GIT_BIN" "$@"
  fi

  # Process arguments
  args=()
  show_help=false
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help)
        show_help=true;;
      --key-file)
        KEY_FILE="${2-}"
        [[ -z "$KEY_FILE" ]] && error "--key-file requires an argument"
        [[ ! -f "$KEY_FILE" ]] && error "$KEY_FILE file not found"
        shift;;
      --with?(out)-@(encryption|permissions))
        option="${1##*-}"
        option="${option^^}_ENABLED"
        # Extra safety: check if the variable exists
        if [[ ! "${!option+set}" ]]; then
          echo "Invalid option: $1"
          exit 1
        fi
        if [[ $1 =~ --without-* ]]; then
          declare "$option"=false
        else
          declare "$option"=true
        fi;;
      --worktree)
        WORKTREE="${2-}"
        [[ -z "$WORKTREE" ]] && error "--worktree requires an argument"
        shift;;
      --)
        shift
        break;;
      *)
        args+=("$1");;
    esac
    shift
  done

  # Restore positional arguments
  set -- "${args[@]}"

  # Build trk command
  # This loop is necessary to allow for optional subcommands
  cmd=""
  for ((i=0; i<$#; i++)); do
    # Try every positional arguments combination in reverse order
    cmd_parts=("${@:1:$#-$i}")
    # cmd_parts is not quoted on purpose to split into array elements
    # shellcheck disable=SC2068
    cmd_probe="$(join_by _ ${cmd_parts[@]})_command"
    if declare -F "$cmd_probe" &>/dev/null; then
      cmd="$cmd_probe"
      shift $(($#-i))
      break
    fi
  done

  if [[ -z "$cmd" ]]; then
    error "Unknown command: ${cmd_parts[*]}"
  fi

  if "$show_help" || [[ "$cmd" == "help_command" ]]; then
    # Display help message and exit.
    help_command "${cmd_parts[*]}"
  fi

  # Validate that the repository is initialized
  if [[ "${GIT_DIR-}" == "$SHARED_GIT_DIR" && ! -d "$SHARED_GIT_DIR" && "$cmd" != init_command && "$cmd" != clone_command ]]; then
    error "$TRK_BIN was not initialized. Run init or clone to initialize."
  fi

  # Run trk
  "$cmd" "$@"
}

main "$@"
